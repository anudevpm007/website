import img0 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-000.png"
import img1 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-001.png"
import img2 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-002.png"
import img3 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-003.png"
import img4 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-004.png"
import img5 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-005.png"
import img6 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-006.png"
import img7 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-007.png"
import img8 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-008.png"
import img9 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-009.png"
import img10 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-010.png"
import img11 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-012.png"
import img12 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-013.png"
import img13 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-015.png"
import img14 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-016.png"
import img15 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-017.png"
import img16 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-018.png"
import img17 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-019.png"
import img18 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-020.png"
import img19 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-022.png"
import img20 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-023.png"
import img21 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-024.png"
import img22 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-025.png"
import img23 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-026.png"
import img24 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-027.png"
import img25 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-029.png"
import img26 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-030.png"
import img27 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-031.png"
import img28 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-032.png"
import img29 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-033.png"
import img30 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-035.png"
import img31 from "@/public/image/BlogSlug/13e8b58a-8edc-4d18-a81b-792d73c38bf4_Hello_Hackers.pdf-image-036.png"
import img2_0 from "@/public/image/BlogSlug/Blog2/image.png"
import img2_1 from "@/public/image/BlogSlug/Blog2/image.webp"




const Blog_data = [
    [
        {
            "h1": "Hello Hackers,"
        },
    
            
        {
            "p": "In this write-up, we\u02bcll explore the fundamentals of game hacking using Assault Cube as our target. We\u02bcll start by learning how to identify dynamic addresses for elements like health and ammo and then progress to finding their static counterparts. Once we have the addresses, we\u02bcll create a simple Lua script to automate value manipulation. By the end of this guide, you\u02bcll understand how to modify in-game values like health and ammo, giving you the ability to customize your gaming experience as you wish. Before we begin, make sure you have the required tools. You can download Assault Cube from here . "
        },
        {
            "IMG": img0
        },
        {
            "PL":{
                "P":"Cheat Engine from ",
                "L":"here.",
                "url":"https://assault.cubers.net/download.html"
            }
        },
    
        {
            "p": " While installing Cheat Engine, your system might flag it as a virus. Don\u02bct worry \u2014this happens because Cheat Engine requires access to system memory to allow you to edit and manipulate values, which some antivirus software misinterprets as malicious behavior. However, you should be cautious about ads on the Cheat Engine website and make sure to decline any additional applications offered during the installation process. Once you\u02bcve done that, proceed with the installation. Lets  dive to our topic, open the game and the cheat engine. You  will get a view of cheat engine like this   ."
        },
        {
            "IMG": img1
        },
    
        {
            "p": " Add the game process to the cheat engine."
        },
        {
            "IMG": img2
        },
        {
            "IMG": img3
        },
    
        {
            "p": " After that setup some basic things in our game for trial activities. Select and enable things as shown bellow."
        },
        {
            "IMG": img4
        },
        {
            "IMG": img5
        },
        {
            "IMG": img6
        },
    
        {
            "p": " After setup , you will get a nice view like this ."
        },
        {
            "IMG": img7
        },
    
        {
            "p": " Now it\u02bcs the time to get our hands dirty. For first what we gonna do is find our health addr and then finding the static addr, for that we going to damage ourself using granade and search for the health value in cheat engine."
        },
        {
            "IMG": img8
        },
    
        {
            "p": "First search 100, cause our current health value is 100."
        },
        {
            "IMG": img9
        },
        {
            "IMG": img10
        },
    
        {
            "p": " After damaging ourself go to cheat engine and enter the new health value and hit next scan. If you die while damaging no problem try again until you get a single value."
        },
        {
            "IMG": img11
        },
    
        {
            "p": "Here you can see the one single value , here mine is 56 you may get different its completely fine. Double click on it and you can see its now in the address list , click on the value and enter a new value . Now you can see the value get changed in the game too."
        },
        {
            "IMG": img12
        },
    
     
        {
            "IMG": img13
        },
        {
            "IMG": img14
        },
    
        {
            "p": "As you see , now we have the dynamic health addr . Now you can give a Description to it like , Dynamic Health or what you need. Next we need to find the static addr . Why ? , Because everytime the game get load to the memory the dynamic addr also get changed so we can\u02bct create a cheat or we cant always use the current addr to change the value , so we need to find the static one. For that right click on the Dynamic Health , Here you can see bunch of options , In the list you can see two options , \u201cFind out what accesses this address\u02ee \u201cFind out what writes to  this address\u02ee"
        },
      
        {
            "IMG": img15
        },
    
        {
            "p": " We are going to choose the first one , \u201cFind out what accesses this address\u02ee"
        },
        {
            "IMG": img16
        },
        {
            "IMG": img17
        },
    
        {
            "p": " After selecting that , then damage agian, now you can see that some access that."
        },
        {
            "IMG": img18
        },
    
        {
            "p": "Here you can see, cmp dword ptr  [esi+000000EC\ue084,00 this means esi + offset \u201cEC\u02ee get compared , so am gonna take this and analysis . I know this one is the correct , but you should mess around with stuff all if you new to this , that\u02bcs how you gonna learn new things . Here esi going to the local local player and EC is the offset for the health addr. We got the the local player right and if we add EC to that ofcourse its going to the health addr and we can modify it , But that not enough because it is dynamic one, we need to find the static. For the learning purpose we can try this for more understanding , click on \u201cAdd Address Manually\u02ee and paste the local player addr \ue09d EC ."
        },
        {
            "IMG": img19
        },
    
        {
            "p": "Enter it and you can see that on the address list , close your game and open it again and import to Cheat Engine . Now you can see that the adrr are no longer work , so that why need to find the static addr.(am not showing this here , you can try it by yourself). Let\u02bcs find that static address. Copy the ESI value and search it , remember to enable the hex because addr are hexadecimal . You can see that green highlighted , thats are statics , we can concentrate on those , the both three will gonna work but maybe after some days or week some won\u02bct work . So we need to pick the most logical one, you will understand if you do more reverse stuff, for now i know the right one, ac_client.exe+195404 ac_client.exe is the module and 195404 is the offset to the player object."
        },
        {
            "IMG": img20
        },
    
        {
            "p": "Add that to the addr list."
        },
        {
            "IMG": img21
        },
        {
            "IMG": img22
        },
    
        {
            "p": "Now we have the static offset to the local player object , we already know the health offset is ' EC , you can do the same thing which we done for the dynamic one , using the add addr manually option. Only a little change . enable the pionter , Because it is [ ac_client.exe+195404 \ue084 , its pointing to the location (to an another pointe) of player object and we need to add another offset to get health which is \u2018EC\u02bc for me . You can compare the image for better understanding , In the previous one we used the dynamic addr \ue09d EC \ue083 007B2244\ue09dEC \ue084 \ue09b health. Here we are using the static offset \u201c195404\u02ee to get the player object [ another pointer ] and then we are adding the offset EC to get the health. [ ac_client.exe+195404 \ue084 \ue09b 007B2158 007B2158 \ue09d EC \ue09b Health. Maybe this help a little bit more, [ ac_client.exe+195404 ] =  007B2158 007B2158  + EC                =  007B2244 007B2244 is addr which storing the health value . 007B2244 = 1035 The bellow image is when the game restarted itself that\u02bcs why the health is 100. You can click ok to save this now or cancel it , am not saving it now (it\u02bcs not a problem anyway)."
        },
        {
            "IMG": img23
        },
    
        {
            "p": "20 If you\u02bcre familiar with registers and pointer it will be easy, if you\u02bcre not this gonna be a little hard , but read it again and do your own research. It\u02bcs ok to feel intimidating, try do the same thing again and again that how you gonna understand the topics. So we find the static local player object and through that we find the health addr also , so what we do if we need to find ammo or coordinates or anything else? , For that you can click on the Memory View. Click Tools."
        },
        {
            "IMG": img24
        },
    
        {
            "p": "Select the option shown bellow."
        },
        {
            "IMG": img25
        },
        {
            "IMG": img26
        },
    
        {
            "p": "Name whatever you want , by default its playerent . Now you can see a lot of information , like coordinates and many other values. I found the health addr , we already knew the offset so i try to look for EC , but if you don\u02bct know the offest look for the value."
        },
        {
            "IMG": img27
        },
        {
            "p": " Here i found the gun ammo , look for initial ammo and shoot observer is there any values getting decreased , then you can find the gun ammo."
        },
        {
            "IMG": img28
        },
        {
            "IMG": img29
        },
    
        {
            "p": " After finding the correct offset for the ammo , look the offset and use \u2018add addr manually\u02bc option, do the same as we done before . Everything is same except the offset . Note \ue092 Your offset may different regarding with the game version, am using AssaultCube 1.3.0.2 . You can make a list like this , use the change color option to make it look cool or like a pro hacker . You can drag and put it in the center of the \u2018Local Player Object\u02bc to get like this , i mean the addr you created ."
        },
        {
            "IMG": img30
        },
    
        {
            "p": "You can add more details as you want , mess around with all things here and spend time until you get a better traction on this. For now am just only added some basics things ."
        },
        {
            "IMG": img31
        }
    ],[
        {"h1":"XYZ router Command Injection "},
        {"h2":"Introduction"},
        {"p":"At Astraliva, we conduct extensive security assessments on IoT devices. In this article, we are presenting a command injection bug we discovered in the firmware of an XYZ IoT device, along with the root cause of the issue. The device is referred to as XYZ throughout this article because we have not received a proper patch from the vendor to date, and the vendor is not happy about us publishing it."},
        {"p":"Also, we wanted to highlight the root cause of the bug in the firmware rather than blindly exploiting it. The XYZ device is a router imported from China, rebranded, and sold in India."},
        {"h2":"Root cause "},
        {"p":"The bug exist in the http webserver named boa."},
        {"IMG":img2_0},
        {"p":"We initially discovered the bug blindly, but for this article, we focused on identifying its root cause. The bug exists in the ping functionality within the device’s diagnostic features. This type of command injection is common in cheap IoT devices and relatively easy to find. After identifying the vulnerability, we extracted the firmware from the device’s SPI flash for further analysis. The hardware hacking aspects of the device will be covered in Part 2 of this article."},
        {"p":"By probing the device via UART, we gained dynamic access and listed the running services, discovering that Boa was the web server in use. As the next step, we began reverse engineering the Boa web server."},
        {"IMG":img2_1},
        {"pa":"After understanding how the web server works, we immediately spotted the bug. The function named #formPing parses the ping request from the diagnostics page. After an #snprintf operation, the buffer named final_buffer is passed to va_cmd (a wrapper for execve) without any sanitization. Since #final_buffer contains the input we given via the diagnostics page, and #va_cmd executes it directly, this leads to command injection."},
        {"h2":"Conclusion "},
        {"p":"In this article, we presented one of the most common and well-known bug classes found in routers. In upcoming articles, we will cover hardware hacking, firmware reverse engineering, and memory corruption bugs."}

    ],
    [
        {"h1":"Automated Security Testing: How Fuzzing Enhances Software Quality"},
        {"p":"In today's fast-paced digital landscape, software security is no longer just a technical necessity—it's a strategic business imperative. A single vulnerability can lead to catastrophic data breaches, legal liabilities, and reputational damage. Enter fuzzing: an innovative and highly effective technique that has become a cornerstone of modern software security testing."},
        {"p":"Imagine your software as a fortress, responsible for safeguarding sensitive data and critical business operations. Fuzzing acts as a relentless security sentry, continuously probing the walls of this fortress, searching for weaknesses before cyber attackers can exploit them. Fuzzing ensures no stone is left unturned in the pursuit of security and reliability."},
        {"h2":"What is Fuzzing?"},
        {"p":"Fuzzing, also known as fuzz testing, is an automated software testing technique that involves injecting unexpected, malformed, or random inputs into a program to detect vulnerabilities. The goal is to uncover bugs that might cause crashes, memory corruption, or unexpected behavior—issues that could otherwise lead to severe security exploits.\n The technique is particularly powerful for compiled languages like C and C++, which are prone to memory-related vulnerabilities such as buffer overflows, null pointer dereferences, and use-after-free errors. However, fuzzing isn’t limited to these languages; it is widely applied to various domains, including:"},
        {"list":["File parsers – Ensuring software correctly handles different file formats without unexpected failures.","Network protocols – Testing how applications process network traffic and identifying potential security flaws.","Web applications – Detecting input validation errors, authentication weaknesses, and injection vulnerabilities."]},
        {"h2":"Why Should Businesses Care About Fuzzing?"},
        {"p":"Security flaws can have severe financial, legal, and reputational consequences for businesses. Fuzzing plays a critical role in minimizing these risks by identifying vulnerabilities early in the software development lifecycle. Here’s why businesses should integrate fuzzing into their security strategy:"},
        {"h3":"1. Cost-Effective Bug Fixing"},
        {"p":"Bugs detected early are significantly cheaper to fix compared to those found after deployment. According to industry studies, fixing a vulnerability post-release can be up to 100 times more expensive than addressing it during development."},
        {"h3":"2. Enhanced Test Coverage"},
        {"p":"Fuzzers can automatically generate and test millions of input variations, far exceeding the scope of manual testing. This leads to more comprehensive vulnerability detection and higher software resilience"},
        {"h3":"3. Protection Against Zero-Day Exploits"},
        {"p":"Zero-day vulnerabilities—flaws that attackers discover before developers do—are a major threat. Fuzzing proactively uncovers these weaknesses, allowing developers to patch them before they can be exploited in the wild."},
        {"h3":"4. Regulatory Compliance and Customer Trust"},
        {"p":"Many industries, such as finance and healthcare, require strict security compliance. Proactively testing software through fuzzing helps businesses meet regulatory requirements and build customer trust by demonstrating a commitment to security."},
        {"h2":"How Fuzzing Works"},
        {"p":"The fuzzing process follows a structured approach to uncovering vulnerabilities:"},
        {"list":["Input Generation: The fuzzer creates test cases by either generating random inputs or mutating existing valid inputs.","Execution & Monitoring: The target software processes these inputs while the fuzzer monitors for crashes, unusual behavior, or security flaws.","Logging & Analysis: If a failure occurs, the fuzzer records the exact input that triggered the issue, providing developers with actionable data for debugging.","Coverage Feedback: Some advanced fuzzers use feedback from program execution (e.g., code coverage analysis) to refine and optimize test cases, increasing the chances of discovering deep-seated bugs."]},
        {"h2":"Types of Fuzzing"},
        {"p":"Different fuzzing techniques offer varying levels of efficiency and depth of testing. Here’s a breakdown:"},
        {"h3": "1. Black-Box Fuzzing"},
        {"list": [
            "Operates without internal knowledge of the application.",
            "Focuses on providing malformed or unexpected inputs to observe responses.",
            "Ideal for testing embedded firmware, legacy, and closed-source software."
        ]},
        
        {"h3": "2. White-Box Fuzzing"},
        {"list": [
            "Utilizes internal program details, such as source code or binary analysis, to craft intelligent test cases.",
            "Offers higher efficiency in finding complex vulnerabilities.",
            "Requires access to the software’s source, making it more resource-intensive."
        ]},
    
        {"h3": "3. Grey-Box Fuzzing"},
        {"list": [
            "A hybrid approach combining black-box and white-box fuzzing techniques.",
            "Uses limited knowledge of the system to optimize test cases.",
            "Balances efficiency and ease of implementation, making it widely adopted in security testing."
        ]},
    
        {"h3": "4. Mutation-Based Fuzzing"},
        {"list": [
            "Takes known valid inputs and slightly modifies them to create test cases.",
            "Efficient in exploring edge cases while ensuring inputs remain somewhat realistic."
        ]},
    
        {"h3": "5. Generation-Based Fuzzing"},
        {"list": [
            "Generates inputs from scratch based on predefined rules or protocol specifications.",
            "Useful for testing highly structured inputs, such as file formats and communication protocols."
        ]},
    
        {"h2": "Integrating Fuzzing into CI/CD Pipelines"},
        {"p": "For modern software development teams, integrating fuzzing into Continuous Integration and Continuous Deployment (CI/CD) pipelines is a game-changer. Automating fuzz testing as part of the development workflow offers several benefits:"},
    
        {"list": [
            "Early Detection: Fuzzing catches vulnerabilities before they reach production.",
            "Continuous Testing: Ensures new code changes do not introduce security regressions.",
            "Faster Development: Automated security testing reduces the burden on manual testers and accelerates software releases."
        ]},
    
        {"p": "Popular fuzzing tools such as AFL++ (American Fuzzy Lop), libFuzzer, and Honggfuzz seamlessly integrate with CI/CD workflows, making automated fuzz testing more accessible than ever."},
    
        {"h2": "Conclusion: Fuzzing as a Business Strategy"},
        {"p": "In an era where cyber threats are more sophisticated than ever, relying solely on traditional testing methods is no longer enough. Fuzzing provides an essential security layer that helps businesses detect and remediate vulnerabilities before attackers can exploit them."},
    
        {"p": "By integrating fuzzing into your software development lifecycle, you not only enhance security but also protect your company's reputation, reduce compliance risks, and ensure the reliability of your products. Investing in fuzzing isn’t just a technical decision—it’s a strategic move that safeguards your business’s future in an increasingly digital world."},
    
        {"p": "In upcoming articles, we will cover hands-on fuzzing of real-life applications to find vulnerabilities using tools like AFL++ and LibFuzzer."}
        
    ]
]


export default Blog_data;